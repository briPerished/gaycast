local textureManager = {}

local SDL = require("SDL")
local image = require("SDL.image")
local ffi = require("ffi")
local vector = require("modules/other/vector")

--[[ 
Returns a table that can be used to access RGB values of provided textures and a table that 
includes the width of said textures
]]
function textureManager.createTextureTables(texturePaths)
    local textures, textureWidths = {}, {}

    for i, path in pairs(texturePaths) do
        local newSurface = assert(image.load(path))
        local surfaceWidth, surfaceHeight = newSurface:getSize()
        local surfaceFormat = newSurface.format
        local bytesPerPixel = 1 --surfaceFormat.BytesPerPixel
        textureWidths[i] = surfaceWidth


        newSurface:lock() --TODO: understandwhy locking is needed

        local surfacePitch = bytesPerPixel * ScreenWidth--newSurface.pitch
        local surfacePixels = ffi.cast("uint8_t*", newSurface.pixels) -- PROBLEM IS: this is nil

        local newTextureData = {}
        for y = 0, surfaceHeight - 1 do
            local rowData = {}
            for x = 0, surfaceWidth - 1 do
                local memoryOffset = (y * surfacePitch) + (x * bytesPerPixel)
                local pixel = 0

                if bytesPerPixel == 1 then --8 bit indexed color
                    pixel = surfacePixels[memoryOffset] --tonumber may be needed
                elseif bytesPerPixel == 2 then
                    local ptr16 = ffi.cast("uint16_t*", surfacePixels + memoryOffset)
                    pixel = tonumber(ptr16[0])
                elseif bytesPerPixel == 3 then --bit shifting is cool,,,
                    local byte1 = tonumber(surfacePixels[memoryOffset + 0])
                    local byte2 = tonumber(surfacePixels[memoryOffset + 1])
                    local byte3 = tonumber(surfacePixels[memoryOffset + 2])

                    if SDL.BYTEORDER == SDL.LIL_ENDIAN then --TODO: figure out wtf is happening here
                        pixel = bit.bor(byte1, bit.lshift(byte2, 8), bit.lshift(byte3, 16))
                    else
                        pixel = bit.bor(bit.lshift(byte1, 16), bit.lshift(byte2, 8), byte3)
                    end
                elseif bytesPerPixel == 4 then
                    local ptr32 = ffi.cast("uint32_t*", surfacePixels + memoryOffset)
                    pixel = tonumber(ptr32[0])
                end

                local r, g, b = SDL.getRGB(pixel, surfaceFormat)

                rowData[x + 1] = {r, g, b}
            end
            rowData[y + 1] = rowData
        end

        textures[i] = newTextureData
        newSurface:free() --oh boy, memory management! my favorite!
    end

    return textures, textureWidths
end

--[[
Returns the RGB value of a certain coord of a texture generated by createTextureTables.
]]
function textureManager.getTextureRGB(coord, texture)
    return texture[coord.y][coord.x]
end

return textureManager